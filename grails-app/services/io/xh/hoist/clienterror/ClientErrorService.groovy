/*
 * This file belongs to Hoist, an application development toolkit
 * developed by Extremely Heavy Industries (www.xh.io | info@xh.io)
 *
 * Copyright Â© 2025 Extremely Heavy Industries Inc.
 */

package io.xh.hoist.clienterror

import com.hazelcast.config.Config
import com.hazelcast.map.IMap
import grails.converters.JSON
import grails.gorm.transactions.Transactional
import groovy.transform.CompileStatic
import io.xh.hoist.BaseService
import io.xh.hoist.cluster.ClusterService
import io.xh.hoist.config.ConfigService
import io.xh.hoist.json.JSONParser
import io.xh.hoist.json.JSONSerializer
import io.xh.hoist.track.TrackLog
import io.xh.hoist.util.Utils

import static io.xh.hoist.browser.Utils.getBrowser
import static io.xh.hoist.browser.Utils.getDevice
import static io.xh.hoist.json.JSONSerializer.serialize
import static io.xh.hoist.util.InstanceConfigUtils.getInstanceConfig
import static io.xh.hoist.util.Utils.getCurrentRequest

import static io.xh.hoist.util.DateTimeUtils.MINUTES
import static io.xh.hoist.util.DateTimeUtils.SECONDS
import static java.lang.System.currentTimeMillis

/**
 * This class manages client error reports, saving them in the database and
 * broadcasting via email.
 *
 * It processes any reports received in a timer in bulk.  With a 'maxErrors' config,
 * this prevents us from ever overwhelming the server due to client issues,
 * and also allows us to produce a digest form of the email.
 */
@CompileStatic
class ClientErrorService extends BaseService {

    /**
     * An example of a closure for custom configuration of associated Hazelcast structures.
     * This is provided statically to allow configuration to be in place before the Hazelcast
     * instance is instantiated.
     * Note the call to `hzName` to get the appropriately qualified name of the resource.
     */
    static configureCluster = { Config c ->
        c.getMapConfig(hzName('clientErrors', this)).with {
            evictionConfig.size = 100
        }
    }

    ClientErrorEmailService clientErrorEmailService
    ConfigService configService

    private int getMaxErrors()      {configService.getMap('xhClientErrorConfig').maxErrors as int}
    private int getAlertInterval()  {configService.getMap('xhClientErrorConfig').intervalMins * MINUTES}

    private IMap<String, Map> errors

    void init() {
        super.init()
        errors = createIMap('clientErrors')
        createTimer(
            name: 'processErrors',
            runFn: this.&processErrors,
            interval: { alertInterval },
            delay: 15 * SECONDS,
            primaryOnly: true
        )
    }

    /**
     * Create a client exception entry. Username, browser info, environment info, and datetime will be set automatically.
     * @param entry - Map containing:
     *      message - optional comments supplied by the user
     *      error - error generated by client-side error reporting
     *      appVersion - expected from client to ensure we record the version user's browser is actually running
     *      url - location where error occurred
     *      userAlerted - whether the user has been alerted to the error
     *      correlationId - optional correlationId for the request associated with this error
     *      tabId -- unique client-side tabId
     *      loadId - unique client-side loadId
     */
    void submit(Map entry) {
        def request = currentRequest
        if (!request) {
            throw new RuntimeException('Cannot submit a client error outside the context of an HttpRequest.')
        }
        if (errors.size() >= maxErrors) {
            logDebug("Client Error received from $authUsername", "maxErrors threshold exceeded - error report will be dropped")
            return
        }

        def userAgent = request.getHeader('User-Agent'),
            now = currentTimeMillis()
        errors[authUsername + now] = [
                // From submission
                username      : authUsername,
                impersonating : identityService.impersonating ? username : null,
                category      : 'ClientError',
                correlationId : entry.correlationId,
                msg           : entry.name,
                elapsed       : null,
                severity      : 'ERROR',
                data          : parseData(entry),
                url           : entry.url?.toString()?.take(500),
                appVersion    : entry.appVersion ?: Utils.appVersion,
                loadId        : entry.loadId,
                tabId         : entry.tabId,
                dateCreated   : new Date(now),


                // From request/context
                instance      : ClusterService.instanceName,
                appEnvironment: Utils.appEnvironment,
                userAgent     : userAgent,
                browser       : getBrowser(userAgent),
                device        : getDevice(userAgent)
        ]
        logDebug("Client Error received from $authUsername", "queued for processing")
    }

    //--------------------------------------------------------
    // Implementation
    //---------------------------------------------------------
    private String parseData(Map entry) {
        def error = JSONParser.parseObject(entry.data as String),
            data = [
                userAlerted: entry.userAlerted,
                userMessage: entry.userMessage,
                error: error
            ]
        return serialize(data)
    }


    @Transactional
    private void processErrors() {
        if (!errors) return

        def maxErrors = getMaxErrors(),
            errs = errors.values().take(maxErrors),
            count = errs.size()
        errors.clear()

        if (getInstanceConfig('disableTrackLog') != 'true') {
            withDebug("Processing $count Client Errors") {
                def trackLogs = errs.collect {
                    def tl = new TrackLog(it)
                    tl.dateCreated = it.dateCreated as Date
                    tl.save(flush: true)
                }
                getTopic('xhClientErrorReceived').publishAllAsync(trackLogs)
                clientErrorEmailService.sendMail(errs, count == maxErrors)
            }
        }
    }

    Map getAdminStats() {[
        config: configForAdminStats('xhClientErrorConfig')
    ]}

}
